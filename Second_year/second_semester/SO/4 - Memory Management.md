# Introduction

What involves memory management?
- Program **loading** and their allocation in memory
- **Translation** of program logical addresses to physical addresses
- Manage presence of **more than one** program in memory and protect their memory spaces
- The ability to **load routines at runtime**
- **Sharing** memory space for several programs
- Execution of **programs that do not fit** in memory
- **Efficient management** of free memory space

# Basic concepts

## Memory hierarchy

![[Pasted image 20240229150938.png]]

## Independent logical spaces

- Program code always refers to program **logical address** between 0 and N
![[Pasted image 20240229151054.png]]
- The execution of a program accesses main memory **physical addresses**

Single-programming systems do not need any special treatment. *physical address=logical address*
In multiprogramming systems memory are shared by several processes. *physical address != logical address*. It's necessary to translate from logical addresses to physical addresses. This process is called **translation, relocation** or **correspondence**.

- **Relocation or correspondence:** Logical to physical address **translation**.
	- **Logical Addresses:** generated by the program
	- **Physical Addresses:** main memory addresses assigned to the process

- **BASIC translation function**
	- **Base register** (first position of the process physical space)
	- **Physical_addr = Logical_addr + base_register**

This translation can be done by hardware or by software

### Software relocation

Translation is done during program loading. In-memory program and executable are different. We don't need special hardware (MMU), but it's difficult to move the process memory space at runtime and we cannot provide complete memory protection
![[Pasted image 20240229152152.png]]

### Hardware translation

The **Memory Management Unit (MMU)** performs the translation by HW. OS is responsible for transfer data to HW for translation: transfer base register value to the MMU when there is a process switch
Translation done **at runtime by the MMU**
![[Pasted image 20240229152453.png]]

- **Monoprogramming**: Only the OS needs protection
- **Multiprogramming:** Processes have to  be protected from each other

It's necessary to validate **all addresses** generated by the program. The hardware does detection and the OS handle it. Basic HW mechanism:

```pseudocode
if address > process size
	then generate an Exception
else translate
```

# Memory Allocation Schemes

**Real Memory:**
- Memory is shared among all existing processes
- The whole process is loaded into memory while existing in the system

**Swapping:**
- To increase the number of processes into the system, processes can be swapped out to some disk area

**Virtual memory:**
- It allows to give processes more memory than the existing in the system
- It's not necessary to load the whole process into main memory to be executed

**Physical memory**
- Contiguous allocation
	- With fixed partitions
	- With variable partitions
- Non-contiguous allocation
	- Simple paging
	- Simple segmentation
	- Segmentation + simple paging

**Virtual memory**
- Paging
- Segmentation
- Segmentation + paging

The most used schema is the **Virtual memory** with paging

## Metrics

**Fragmentation:** % of memory that cannot be used.
- **Internal fragmentation:** Memory space assigned to a process that is not in use
- **External fragmentation:** Memory space that is not assigned to any process and it's not useful
- **Table fragmentation:** Memory space used by the OS to store the data structures needed to manage memory

# Physical memory

## Contiguous allocation

### Fixed partitions

Memory is divided into a **fixed number** or **fixed-size** partitions. The admin can configure the number of partitions and the size of each one, but it requires rebooting. Each process is assigned a free partition that fits, according to the *allocation policy* used by the OS.
The data structures needed for control are simple. Generates no **external fragmentation**, but it does generates **internal fragmentation** (the wasted space in one partition cannot be used by another process)

>[!Advantages]
>- Simplicity of implementation
>- Memory translation simple and efficient
>- Processes have separate logical spaces
>- Ensures protection processes

>[!Disadvantages]
>- Sharing memory is impossible
>- Does not support region management
>- Limits the degree of multiprogramming
>- Limits the size of the memory map of the processes


### Variable partitions

When system starts, available memory appears as one unique continuous space. When a process is created, memory is taken from the free space. The assigned partition depends on the **allocation policy** used: *Best fit*, *Worst fit*, *First fit*, *Buddy*
The data structures needed for control are simple but more complex than the fixed ones. Generates **external fragmentation**, which must be resolved by the system.
![[Pasted image 20240229173617.png]]

>[!Advantages]
>- Relative simple implementation. (More complex than the fixed one)
>- Memory translation simple and efficient
>- Processes have separate logical spaces
>- Ensures protection of the processes

>[!Disadvantages]
>- Sharing memory impossible
>- Does not support region management
>- Limits the degree of multiprogramming (Less than fixed partitions)
>- Limits the size of the memory map of the processes (less than fixed partitions)


>[!Important]
>Exam until Physical memory - Contiguous allocation - variable partitions
>
>Physical memory with non-contiguous allocation is not seen in this course (We jump directly to Virtual memory)
>

## Non-contiguous allocation

## Segmentation + paging

Each process uses a **segment table** and several **page tables**.
Address translation:
![[Pasted image 20240314151329.png]]

>[!Advantages]
>- Increase the degree of multiprogramming
>- Increase the size of the memory map of the process
>- Processes have separate logical spaces
>- Ensures protection of the processes
>- Enables memory sharing
>- Contemplate regions management

>[!Disadvantages]
>Memory translation is not simple and efficient $\rightarrow$ + complicated than paging but - than segmentation

# Virtual memory

It expands main memory using disk as temporary storage. We don't need to have the whole process memory space loaded in main memory to be able to execute it. Process image is divided into fragments, loaded and unloaded as needed. **Non-contiguous allocation** is used.

>[!The locality principle]
>*When referring to a memory address is very likely to refer to the **same** address or **others nearby** in a short time*
>
>Memory references tend to group in relatively small areas of process memory space during some time interval

Advantages:

1. The size of a process size may be greater than the physical memory space. The logical address space could reach 2 raised to the number of bits of the address bus, regardless of the amount of available memory in the system.
2. It increases the degree of multiprogramming
	- Allocates a small portion of memory for each process
	- **More processes fit** into main memory
3. Transparent to the programmer. **It's managed by the OS**

## Paging

Division of the process address space into fragments called **pages**.
Division of the main memory into fragments called **frames**
Frames and pages have the **same size**
Process pages can be loaded into any frame
Process logical address is mapped into a pair (page, offset)
Memory physical address is mapped into a pair (frame, offset)

To translate a logical address we only need to substitute the number of the page with the number of the frame where that page is loaded. If that page is not loa


## Segmentation

Applies the concept of region to the memory management. A process consists of a set of segments, each with its own address space. Each segment stores a region of the process and is stored in adjacent positions. Uses a segment table per process, to store the size, load bit, modification bit... . It needs a partition table to manage free/busy partitions in the system

>[!Advantages]
>- Increase the degree of multiprogramming
>- Process have separate logical spaces
>- Ensures protection of the processes
>- **Enables memory sharing**
>- **Contemplate regions management**

>[!Disadvantages]
>- Memory translation is not simple and efficient
>- Difficult storage management


## Segmentation + paging


Puts together the advantages of the Segmentation for logical space management and Paging for physical space management. A process consists of a set of segments, each with its own address space. Each segment is divided into a set of pages of equal size. The memory is divided into page frames of equal size. Each process will have a table of segments and each segment a page table


# Virtual memory management

**2 types of design decisions**

- Hardware Dependent
	- Paging, Segmentation, Segmentation + Paging

- Software Dependent
	- What to do with **page faults**
	- Policies for storage management
		- Reading Policies
		- Replacement policies
		- Allocation policies

![[Pasted image 20240314152640.png]]

## Reading policies

**Determines when to load a page in memory**

**On demand paging** $\rightarrow$ Brings to memory when there's a page fault
**Pre-paging** $\rightarrow$ Bring to memory several contiguous pages. Increased load efficiency from secondary memory

## Replacement policies

Determines which page in main memory **to page out** when we need to load another and there's no room for her. The replacement scope can be:
**Global** $\rightarrow$ Replaces one page of any process in memory
**Local** $\rightarrow$  Replaces one page belonging to the process that requires the new one

## Allocation policies

Determines **how many frames are assigned** to a process. 